# Введення

В даній статті виконується огляд концепції вектора та її форматів задання.

Унікальними особливостями реалізації математики над векторами цього модуля є:
- Чистота: модуль не здійснює інжекцію методів, не забруднює і не змінює стандатрний інтерфейс.
- Вектор: є звичайним масивом або типізованим буфером.
- Модуль використовує принципи функціонального програмування.
  - Вектор не є об'єктом і не має полів "x", "y", "z".
  - Всі математичні функції мають реалізацію, що приймає вектори в якості аргументів, а не контексту.
  - Адаптер - незмінюваний ( nonmutable ) об'єкт.
- Читабельність та лаконічність коду є так само важливою, як його швидкодійність.
- Володіє великою гнучкість завдяки можливості задати вектор через адаптер.
- Реалізує один і той самий інтерфейс для різним типів даних і форматів їх задання. Код написаний для адаптера не відрізняється від коду написаного для масиву.
- Має хороше тестове покриття та документацію.
- Під NodeJS використовує опціональну зв'язку із нативною реалізацією [BLAS-like](https://github.com/flame/blis) бібліотеки ( не готово ).
- В оптимізованій збірці має високу швидкодійність ( не готово ).

### Концепція вектор

Під вектором в даному модулі розуміється впорядкована сукупність скалярів.

### Формати задання вектора

Вектор може бути заданий через

- через масив( Array )
- через типізований буфер ( BufferTyped )
- через адаптер ( VectorAdapter )

Для використання вектора в масиві або буфері використовуйте неймспейс `_.avector`. Для використання вектора заданого адаптером використовуйте неймспейс `_.vectorAdapter`.

### Проста операція над векторами

Простий приклад оперпції додавання двох векторів.

```js
var vector1 = [ 1, 2, 3 ];
var vector2 = [ 4, 5, 6 ];

_.avector.add( vector1, vector2 );

console.log( vector1 );
/* log : [ 5, 7, 9 ] */
console.log( vector2 );
/* log : [ 4, 5, 6 ] */
```

Вектор `vector1` використовується одночасно і як контейнер для зберігання результату і як один із аргументів математичної функції.

### Адаптер це абстракція

Вектор може бути заданий і через адаптер. Адаптер це спеціальний об'єкт, який потрібний для того щоб зробити алгоритми більш абстрактними і використовувати один і той же код для дуже різних форматів задання вектора.

```js
var array1 = [ 1, 2, 3 ];
var array2 = [ 4, 5, 6 ];
var vector1 = _.vectorAdapter.from( array1 );
var vector2 = _.vectorAdapter.from( array2 );

console.log( vector1.toStr() );
/* log : "1.000, 2.000, 3.000" */
console.log( vector2.toStr() );
/* log : "4.000, 5.000, 6.000" */

_.vectorAdapter.add( vector1, vector2 );

console.log( vector1.toStr() );
/* log : "5.000, 7.000, 9.000" */
console.log( vector2.toStr() );
/* log : "4.000, 5.000, 6.000" */

console.log( array1 );
/* log : [ 5, 7, 9 ] */
console.log( array2 );
/* log : [ 4, 5, 6 ] */

```

Створюєм масиви `array1` та `array2`. Для них задаєм прості адаптери `vector1` та `vector2`. Додаєм вектори оперуючи адаптерами. Бачемо, що змінилося не лише значення `vector1`, а й значення `array1`.

Вижливо: адаптери не володіють даними. Матефорично кажучи, адаптер є продвинутим різновидом лінка на дані.

### Адаптер це різновид посилання.

Інший приклад із адаптером: множення вектора на скаляр.

```js
var array = [ 1, 2, 3 ];
var vector1 = _.vectorAdapter.from( array );

_.avector.mul( array, 2 );

console.log( vector1.toStr() );
/* log : "2.000, 4.000, 6.000" */
```

Адаптер `vector1` не створює копії вектора, а є посиланням на дані оригінального масива `array`, тому після виконання операції множення над масивом адаптер має значення в 2 рази більші від початкового.

### Адаптер це інтерпретація

Інша технічна метафора - інтерпретація. Адаптер не володіє даними, а вказує на них і задає спосіб їх інтерпретації.

### Альтернативні інтерфейси

В даному прикладі показано 3 альтернативних способи використання одного й того ж інтерфейсу.

```js

var array1 = [ 1, 2, 3 ];
var adapter1 = _.vectorAdapter.from( array1 );

_.avector.mul( array1, 2 );
_.vectorAdapter.mul( adapter1, 2 );
adapter1.mul( 2 );

console.log( adapter1.toStr() );
/* log : "8.000, 16.000, 24.000" */

```

Три послідовні операції множення вектора з використанням контейнера даних `array1`, з використанням адаптера `adapter1` і з використанням метода `adapter1.mul()` адаптера збільшують значення всіх елементів вектора в 8 разів.

### Конвенція dst=null

Задайте значення першого аргумента як `null` ( `dst = null` ) щоб результат операції був записаний в новий вектор.

```js

var srcVector1 = [ 1, 2, 3 ];
var srcVector2 = [ 4, 5, 6 ];
var dstVector = _.avector.add( null, srcVector, srcVector2 );

console.log( srcVector1 );
/* log : [ 1, 2, 3 ] */
console.log( srcVector2 );
/* log : [ 4, 5, 6 ] */
console.log( dstVector );
/* log : [ 5, 7, 9 ] */
console.log( dstVector === srcVector );
/* log : false */

```

Так, як першим аргументом виклику `_.avector.add` є `null` то для запису результату додавання двох векторів `srcVector1` та `srcVector2` створюється новий контейнер такого ж типу як і вхідні аргументи, й в нього записується результат.

Така ж конвенція діє для всіх адаптерів та для всіх рутин модуля `MathVector`.

### Перевага використання адаптерів

Так як адаптер є реалізацією абстрактного інтерфейсу то вона, ця реалізація, може бути будь-якою. Зміна реалізації вектора ніяк не вплине на алгоритми над векторами.

### Адаптер з області ( range )

Скажімо є довгий типізований `Float32` буфер `buffer1` довжиною в гігабайт й другий буфер `buffer2` довжиною в мегабайт. Десь в першому буфері, з якимось зсувом, захований вектор. Увесь другий буфер інтерпретуємо, як вектор. Як здійснити множення першого вектора на другий із збереженням результату в першому буфері?

```js

var buffer1 = new F32x([ 1, 2, 3, 4, 5, 6, 7 ]);
var buffer2 = new F32x([ 4, 5, 6 ]);
var vector1 = _.vectorAdapter.from( buffer1, 1, 3 );
var vector2 = _.vectorAdapter.from( buffer2 );

console.log( vector1.toStr() );
/* log : "2.000, 3.000, 4.000" */
console.log( vector2.toStr() );
/* log : "4.000, 5.000, 6.000" */

_.vectorAdapter.add( vector1, vector2 );

console.log( vector1.toStr() );
/* log : "6.000, 8.000, 10.000" */
console.log( vector2.toStr() );
/* log : "4.000, 5.000, 6.000" */

console.log( vector1 );
/* log : [ 1, 6, 8, 10, 5, 6, 7 ] */
console.log( vector2 );
/* log : [ 4, 5, 6 ] */

```

При створенні адаптера `vector1` до буфера `buffer1` передаємо зсув в `1` елемент та задаємо, що вектор має довжину `3` елемента. Увесь другий буфер інтерпретуємо, як вектор. Результат операції додавання записується в вектор `vector1`. Так, як адаптер було створено із елементів 1 - 3 буфера `buffer1` то значення всіх елементів за межами цієї області ( range ) залишилися без змін.

### Порівняння із стандатними типізованими буферами

Цього ж можна досягти й [задаючи зсув](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/byteOffset) та [розмір](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/byteLength) типізованого буфера ( BufferTyped ) при його конструюванні із нетипізованого буфера ( BufferRaw ). Але на цьому можливості стандартних представлень завершуються. Стандатьні представлення не дають можливості:

- Задати ширини кроку ( stride ).
- Змінити напрямок.
- Задати комплексний формат даних.
- Використати масив або масив аргументів як оригінальний контейнер даних, лише нетипізований масив.

### Задання ширини кроку ( stride )

Приклад подібний до попереднього. Є довгий типізований `Float32` буфер `buffer1` довжиною в гігабайт й другий буфер `buffer2` довжиною в мегабайт. Десь в першому буфері, з якимось зсувом, захований вектор. Увесь другий буфер інтерпретуємо, як вектор. Як здійснити множення першого вектора на другий із збереженням результату в першому буфері? Але цього разу припустимо, що вектор в першому буфері не лише не починається із початку, але й не йде послідовно. Припустимо вектора `vector1` має ширину кроку 2. Тобто кожен наступний елемент вектора `vector1` знаходиться в буфері `buffer1` через один.

```js

var buffer1 = new F32x([ 1, 2, 3, 4, 5, 6, 7 ]);
var buffer2 = new F32x([ 4, 5, 6 ]);
var vector1 = _.vectorAdapter.fromLongLrangeAndStride( buffer1, 1, 3, 2 );
var vector2 = _.vectorAdapter.from( buffer2 );

console.log( vector1.toStr() );
/* log : "2.000, 4.000, 6.000" */
console.log( vector2.toStr() );
/* log : "4.000, 5.000, 6.000" */

_.vectorAdapter.add( vector1, vector2 );

console.log( vector1.toStr() );
/* log : "6.000, 9.000, 12.000" */
console.log( vector2.toStr() );
/* log : "4.000, 5.000, 6.000" */

console.log( vector1 );
/* log : [ 1, 6, 3, 9, 5, 12, 7 ] */
console.log( vector2 );
/* log : [ 4, 5, 6 ] */

```

Рутина `_.vectorAdapter.fromLongLrangeAndStride` створює адаптер `vector1` із зсувом `1` елемент, довжиною `3` елементи та шириною кроку `2` елементи. Додавання вектора `vector2` до вектора `vector1`.

### Змішування різних типів векторів

Вектори з різними типами елементів можливо змішувати.

Підтримуються такі типи:

- `Array`;
- `ArgumentsArray`;
- `Number`;
- `I8x` ( `Int8Array` );
- `U8x` ( `Ui8Array` );
- `U8ClampedX` ( `Ui8ClampedArray` );
- `I16x` ( `Int16Array` );
- `U16x` ( `Ui16Array` );
- `I32x` ( `Int32Array` );
- `U32x` ( `Ui32Array` );
- `F32x` ( `Float32Array` );
- `F64x` ( `Float64Array` );
- `I64x` ( `BigInt64Array` );
- `U64x` ( `BigUint64Array` ).

### Змішування форматів векторів

Рутини неймспейсу `_.avector` можуть працювати як з адаптерами так і з стандартними типами.

Рутини неймспейса `_.vectorAdapter` викидуються помилку при при спробі передати їм не адаптер.

### Інтерфейс адапатера

Інтерфейс адаптера реалізує мінімалну множину методів і полів необхідних для оперування вектором. Серед таких:

- Метод `eGet( i )` - від "element get" для того щоб отримати значення i-го елемента.
- Метод `eSet( i, e )` - від "element set" для того щоб всановити значення i-го елемента.
- Поле `length` - довжина вектора в елементах.

### Приклад складного формату задання вектора

Формат в якому задається вектор захований за абстрактним інтерфейсом тому він може мати будm-яку складніст і його деталі реалізації не мають значення для алгоритмів модуля `MathVector`.

Для прикладу число можливо інтерпретувати, як вектор довільної довжини.

```js

var vector1 = _.vectorAdapter.fromNumber( 1, 3 );
var vector2 = _.vectorAdapter.from([ 4, 5, 6 ]);

console.log( vector1.toStr() );
/* log : [ 1, 1, 1 ] */
console.log( vector2.toStr() );
/* log : [ 4, 5, 6 ] */

_.vectorAdapter.add( vector2, vector1 );

console.log( vector1.toStr() );
/* log : [ 1, 1, 1 ] */
console.log( vector2.toStr() );
/* log : [ 5, 6, 7 ] */

```

Адаптер `vector1` створюється із числа. Всі значення вектора `vector1` мають значення `1`, а його довжина `3` елементи. Додавання вектору `vector1` до вектору `vector2` має такий же ефекти які додавання скаляра `1` до вектору `vector2`.

Приклад має продемонструвати гнучкість вектор адаптерів.

### Приведення до типу Long

Для того щоб конвертувати адаптер в тип `Long` використайте рутину `_.avector.toLong()`. Рутина `toLong` повертає оригінал, що стоїть за адаптером якщо це можливо, інакше створює новий контейнер такого ж типу, як і оригінал із вектором у вмісті.

```js

var long1 = new F32x([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
var vector1 = _.vectorAdapter.fromLongLrangeAndStride( long1, 1, 3, 2 );
var long2 = _.avector.toLong( vector1 );

console.log( long2 );
/* log : [ 1, 3, 5 ] */
console.log( _.strType( long2 ) );
/* log : Float32Array */

```

### Підсумок

- Модуль має 2 неймспеси - `_.avector` i `_.vectorAdapter`.
- Рутини неймспесу `_.avector` працюють з векторами у вигляді `Long`-контейнерів.
- Рутини неймспесу `_.vectorAdapter` для роботи із адаптерами.
- Адаптери - це абстракція, різновид посилання, що задає спосіб інтерпретації даних.
- Адаптери не володіють даними, не містять безпосередньо даних вектора, а лише метадані - лінк на дані, початок вектору, довжину, тип, тощо.
- Адаптером можливо не лише вибрати поміжок буфера, який потрібно інтерпретувати, як вектор, але й задати ширину крок ( stride ).
- `null` в першому аргументі змінює семантику рутини примушуючи її створити новий контейнер.
- Реалізації інтерфейсу адаптера може мати довільну складніс.

[Повернутись до змісту](../README.md#Туторіали)
